We are comparing other tools to the Determinism Checker.
Can we try to run those other tools on Randoop?
I think that would be a compelling way to argue that they don't scale.
Using a type-checker does require a commitment of time to do annotations,
which we should admit, of course.





We should claim that we did an informal, paper-and-pencil proof of the core of the type system.
We did not do a machanized proof (such as in Coq, Isabelle, or K).
We did not do any proofs about the implementation.


===========================================================================


One thing to mention is that in the Randoop case study, there were many
places where I might have had to suppress warnings because of iterating
over a @PolyDet collection where the looping variable would be
@PolyDet("up"). For example, the copyList method we've discussed would
require suppressing warnings. However, for methods like that I took the
approach of making all the parameters @Det, which allowed the method to
type check. I wouldn't have done this in a library where we would want most
of the signatures to be general and take @PolyDet parameters. In Randoop,
however, the approach I took simply increased the number of annotations
written while decreasing the number of @SuppressWarnings used.


* Our type refinement for sorting also refines PolyDet List<Det T> to
  PolyDet("down") List<Det T>, so the sorting rule might be better
  expressed in terms of the "down" operator.
Response: @PolyDet is not a type, but a type variable.
The proposal about expressing the sorting rule could still be a good one, though.

* Originally, exceptions in catch blocks were @NonDet. This caused a huge
 amount of errors and so we eventually decided to remove this and default
 exceptions in catch blocks to deterministic. This caused some unsoundness,
 but only in the case exceptions are thrown. It also made the checker much
 more usable.
Response: mention that throws clauses in the program are required to be @Deterministic

* Finally, one major issue we have with our checker is mixing class level
 fields and type parameters with polymorphic qualifiers. First, the fact
 that fields cannot be assigned to a @PolyDet value is a big deal. It's
 what caused me to write most of the annotations that I did in randoop. The
 issue with type parameters is that it's illegal to have a parameter
 "@PolyDet List<T> list" where <T extends @NonDet Object> (because the
 upper bound of T must be a subtype of @PolyDet). This was actually an
 issue in plume-util when we wanted generality. In Randoop I simply changed
 the upper bound of the type parameters to @Det. A more important
 consequence is that I don't think our JDK annotations for collections
 would type check at all because PolyDet List<T> where <T extends @NonDet
 Object> is the receiver for many of these methods, and it's illegal to
 write this. Note, both of these problems would be solved by @ThisDet.
Respones: It would be interesting to discuss why type polymorphism was not sufficient.
