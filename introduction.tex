\section{Introduction}

A nondeterministic program may produce different output on different runs
when provided with the same input.
Nondeterminism is a serious problem for software developers and users.
\todo{Add lots of citations in the below.}
\begin{itemize}
\item
  Nondeterminism makes a program difficult to \textbf{test}, because test
  oracles must account for all possible behaviors while still enforcing
  correct behaviors.  Test oracles that are too strict lead to flaky tests
  that sometimes pass and sometimes fail.  Flaky tests must be re-run, or
  developers ignore them; in either case, their utility to detect defects
  is limited.
\item
  Nondeterminism makes it difficult to \textbf{compare} two runs of a
  program on different data, or to compare a run of a slightly modified
  program to an original program.  This hinders debugging and maintenance,
  and prevents use of techniques such as Delta Debugging~\cite{Zeller1999}.
\item
  Nondeterminism may make outputs incompatible with previous outputs relied
  on by users or by other systems.\todo{Citations about bugs related to this?}
\item
  Nondeterminism reduces users' and developers' \textbf{trust} in a program's output.
\end{itemize}

Two well-known sources of nondeterminism are concurrency
% (due to OS scheduling or message delivery over a network)
and coin-flipping
(calls to a \<random> API\@).
It may be surprising that nondeterminism is common even in sequential
programs that do not flip coins.
For example, any program that iterates over a set or map, and that uses the
results to affect the output, may produce different output on different runs.
So may any program that uses default formatting, such as Java's
\<Object.toString()> which includes an address or hash code.
Other nondeterministic APIs include date-and-time functions and
accessing system properties such as the file system or environment variables.

We have created an analysis that detects nondeterminism or verifies its
absence.
Our analysis permits programmers to specify which parts of their program
are intentionally nondeterministic, and it verifies that the remainder is deterministic.
%
Our analysis is sound:  if it issues no warnings, then the program does not
suffer nondeterminism of the given types.  (If the program uses concurrency,
it might still be nondeterministic.)
%
Our analysis works at compile time, giving a guarantee over every possible
execution of the program, by contrast to unsound dynamic tools that attempt
to discover when a program has exhibited nondeterministic behavior on
specific runs.  There is no need for a special JVM nor rerunning a program
multiple times.
%
Our analysis handles collections that will contain the same values, but
possibly in a different order, on different runs.
%
Our analysis is precise enough for practical use.  It permits calls to
nondeterministic APIs, and only issues a warning if they are used in ways
that may lead to nondeterministic output observed by a user.  Like any
sound analysis, it can issue false positive warnings.



The high-level goal of our work is to provide programmers with a tool for
specifying deterministic properties in a program and verifing them
at compile time.


Other researchers have also recognized the importance of this problem.
Previous work in program analysis for nondeterminism has focused on unsound dynamic
approaches that identify flaky test cases.
NonDex~\cite{nondex} is a tool that manually\todo{This is confusing:  the
  tool can't manually identify.  Do you mean that the developers manually
  identified, then the tool uses those models?}
identifies methods in the JDK that have nondeterministic specifications, builds models for
these methods that behave nondeterministically, and  use a modified JVM that runs the test suite multiple times.
Diverging test results in this setting indicate a flaky test. DeFlaker~\cite{deflaker} looks at a range of commit versions
of a code, and marks a test as flaky if it doesn't execute any modified code but still fails in the newer version. These techniques
have been able to identify issues in real-world programs, some of which
have been fixed by the developers. We believe that identifying and
resolving nondeterminism
at an earlier phase in the software development lifecycle would be greatly beneficial to
developers.

We have defined a type system with three types\todo{reference a figure}:
\<Det> represents values that will be the same across executions,
\<OrderNonDet> represents collections that are guaranteed to contain the same elements albeit in possibly
different iteration order, and
\<NonDet> provides no determinism guarantees:  it represents values that
might differ from run to run.
Programmers can write these types to specify their program's behavior.
Our type system contains a variety of other features that increase
expressiveness and reduce false positive alarms.\todo{reference a section}

We have implemented this type system in the context of Java.
We annotated all the collection
classes (Lists, Sets and Maps) in the JDK with our new type system.

We have run experiments\todo{describe them}.
We found this type hierarchy
is expressive enough to identify nondeterministic behaviors in production software.

This paper makes the following contributions:
\begin{enumerate}
	\item We provide a design and implementation of a type system for expressing deterministic properties in sequential programs.
	\item We annotated several classes in JDK. By doing this, we have translated the specification for these APIs from
	human readable comments to machine readable and verifiable documentation.
	\item We performed a case study of a real world java program Randoop (loc, etc) which revealed bugs.
	\item We perform a comparative study of our technique with state of the art flaky test detectors and present results.
\end{enumerate}

% LocalWords:  NONDEX NonDex DeFlaker
