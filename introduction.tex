\section{Introduction}

A nondeterministic program may produce different output on different runs
when provided with the same input.
Nondeterminism is a serious problem for software developers and users.
\todo{Add lots of citations in the below.}
\begin{itemize}
\item
  Nondeterminism makes a program difficult to \textbf{test}, because test
  oracles must account for all possible behaviors while still enforcing
  correct behaviors.  Test oracles that are too strict lead to flaky tests
  that sometimes pass and sometimes fail.  Flaky tests must be re-run, or
  developers ignore them; in either case, their utility to detect defects
  is limited.
\item
  Nondeterminism makes it difficult to \textbf{compare} two runs of a
  program on different data, or to compare a run of a slightly modified
  program to an original program.  This hinders debugging and maintenance,
  and prevents use of techniques such as Delta Debugging~\cite{Zeller1999}.
\item
  Nondeterminism may make outputs incompatible with previous outputs relied
  on by users or by other systems.\todo{Citations about bugs related to this?}
\item
  Nondeterminism reduces users' and developers' \textbf{trust} in a program's output.
\end{itemize}

Two well-known sources of nondeterminism are concurrency
% (due to OS scheduling or message delivery over a network)
and coin-flipping
(calls to a \<random> API\@).
It may be surprising that nondeterminism is common even in sequential
programs that do not flip coins.
For example, any program that iterates over a set or map, and that uses the
results to affect the output, may produce different output on different runs.
So may any program that uses default formatting, such as Java's
\<Object.toString()> which includes an address or hash code.
Other nondeterministic APIs include date-and-time functions and
accessing system properties such as the file system or environment variables.

We have created an analysis that detects nondeterminism or verifies its
absence.
Our analysis permits programmers to specify which parts of their program
are intentionally nondeterministic, and it verifies that the remainder is deterministic.
%
Our analysis is sound:  if it issues no warnings, then the program does not
suffer nondeterminism of the given types.  (If the program uses concurrency,
it might still be nondeterministic.)
%
Our analysis works at compile time, giving a guarantee over every possible
execution of the program, by contrast to unsound dynamic tools that attempt
to discover when a program has exhibited nondeterministic behavior on
specific runs.  There is no need for a special JVM nor rerunning a program
multiple times.
%
Our analysis handles collections that will contain the same values, but
possibly in a different order, on different runs.
%
Our analysis is precise enough for practical use.  It permits calls to
nondeterministic APIs, and only issues a warning if they are used in ways
that may lead to nondeterministic output observed by a user.  Like any
sound analysis, it can issue false positive warnings.



The high-level goal of our work is to provide programmers with a tool for
specifying deterministic properties in a program and verifying them
at compile time.


Other researchers have also recognized the importance of this problem.
Previous work in program analysis for nondeterminism has focused on unsound dynamic
approaches that identify flaky test cases.
NonDex~\cite{nondex} is a tool that manually\todo{This is confusing:  the
  tool can't manually identify.  Do you mean that the developers manually
  identified, then the tool uses those models?}
identifies methods in the JDK that have nondeterministic specifications, builds models for
these methods that behave nondeterministically, and  use a modified JVM that runs the test suite multiple times.
Diverging test results in this setting indicate a flaky test. DeFlaker~\cite{deflaker} looks at a range of commit versions
of a code, and marks a test as flaky if it doesn't execute any modified code but still fails in the newer version. These techniques
have been able to identify issues in real-world programs, some of which
have been fixed by the developers. We believe that identifying and
resolving nondeterminism
at an earlier phase in the software development lifecycle would be greatly beneficial to
developers.

Our analysis uses three main abstractions, or approximations to run-time values:
\begin{description}
\item[\<Det>] represents values that will be the same across executions.
\item[\<OrderNonDet>] represents collections that are guaranteed to contain the same elements albeit in possibly
different iteration order.
\item[\<NonDet>] represents values that
might differ from run to run.
\end{description}
\noindent
Programmers can write these to specify their program's behavior.
Our type system contains a variety of other features that increase
expressiveness and reduce false positive alarms.\todo{reference a section}

We have implemented this analysis as a pluggable type system for Java.

We have run experiments\todo{describe them}.
We found this type hierarchy
is expressive enough to identify nondeterministic behaviors in production software.

This paper makes the following contributions:
\begin{enumerate}
  \item We designed a type type system for expressing determinism properties.

  \item We implemented the type system for Java.

  \item In a case study, we annotated several libraries, including the
    relevant parts of the JDK (Java's standard library).  This provides a
    formal, machine-readable specification for the libraries, and it
    demonstrates the richness of our type system.

  \item In another case study, we ran our analysis on a 24 KLOC project that
    developers had spent weeks of effort to make deterministic.  Our system
    discovered nondeterminism that the developers had overlooked, and they
    accepted our patches.

  \item We compared our tool against state-of-the-art flaky test
    detectors.\todo{Say something about the results.}
\end{enumerate}

% LocalWords:  NONDEX NonDex DeFlaker Det OrderNonDet NonDet
