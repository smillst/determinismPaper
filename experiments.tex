\section{Comparison to previous work}

The state of the art in flaky test detection is NonDex~\cite{nondex}.
\Cref{sec:related} explains how NonDex works. In this section, we perform a qualitative comparison of the
errors reported by NonDex and those reported by \TheDeterminismChecker. We ran all our
experiments on a 2.3 GHz Intel Core i5 processor with a RAM configuration of 8 GB 2133 MHz.
\TheDeterminismChecker doesn't show any noticeable performance change at compile time.
\TheDeterminismChecker runs on any project that builds with maven or gradle and requires
Java version 8 or higher (support for annotations was added in Java 8).

\subsection{Case study with NonDex}\label{sec:nondex-randoop}

We ran NonDex on the same commit of Randoop as we used for the case study
of \cref{sec:randoop-case-study}.  This version contains 3 nondeterminism bugs that
\theDeterminismChecker found.

We modified Randoop by deleting tests that were skipped by its buildfile,
because the NonDex gradle plugin does not respect those settings. 
After that, NonDex ran without problems on Randoop.
It completed successfully without reporting any flaky tests.
We investigated the tests covering code that \theDeterminismChecker reported as nondeterministic.
Bug 1 and Bug 2 have corresponding test cases whereas Bug 3 does not.
As NonDex is a \textit{flaky test} detection tool, Bug 3 is outside of its scope.
The reason for nondeterminism in Bug 2 was a call to the \<System.getProperty()> method which
is not modeled by NonDex.
This indicates that the additional programmer effort required by \TheDeterminismChecker is justified
as our tool discovers non-trivial issues and doesn't depend on code coverage or other runtime heuristics.

\subsection{\TheDeterminismChecker on NonDex benchmarks}\label{sec:nondex-benchmarks}

\Cref{sec:nondex-randoop} shows that \theDeterminismChecker finds errors that NonDex does not.
This section determines whether NonDex finds errors that \theDeterminismChecker does not.
Its authors ran NonDex on 195 open-source projects, and NonDex found flaky tests in
21 of them. We defer the reader to~\cite{nondex} for a complete list of these projects
and the details of commits hashes in which NonDex detected flaky tests.
The authors also reported the sources of flakiness
after manually inspecting these tests. 

We ran \TheDeterminismChecker on all these benchmarks with the objective
of measuring the recall of our tool. We cloned all 21 repos and switched to the commit that had a flakiness issue as reported 
in~\cite{nondex}. Of these projects, \<handlebars> and \<oryx> have compile time failures which prevent us from running \TheDeterminismChecker on them. For benchmarks \<visualee>, \<easy-batch>, and \<vraptor>, we couldn't find
the sources of flakiness as reported in~\cite{nondex} anywhere in the respective repositories.
\TheDeterminismChecker reported the nondeterministic source locations correctly in the rest of the projects.
All these benchmarks and instructions to reproduce our results can be found at \href{https://github.com/t-rasmud/determinismCaseStudies}{https://github.com/t-rasmud/determinismCaseStudies}.

All the flakiness that NonDex found was due to 7 methods in 3 classes. We enumerate all the methods corresponding to
each class in Figure~\ref{fig:flaky-sources}.
\begin{figure}
    \begin{tabular}{lll}
        \<Class> & : \<getDeclaredFields>, \<getDeclaredMethods>, \<getFields> \\
        \<DateFormatSymbols> & : \<getZoneStrings> \\
        \<HashMap> & : \<entrySet>, \<keySet>, \<values>
    \end{tabular}
\caption{Souces of flakiness in~\cite{nondex}.}
\label{fig:flaky-sources}
\end{figure}

We provide samples of the annotated source code from these benchmarks and the errors as reported by \TheDeterminismChecker 
in Figure~\ref{fig:nondex-source}.
\begin{figure}
    \centering
    \begin{subfigure}[b]{0.95\textwidth}
        \begin{verbatim}
    static public FieldAccess get (Class type) {
        @Det ArrayList<@Det Field> fields = new ArrayList<Field>();
        ...
        while (nextClass != Object.class) {
            @Det Field @Det[] declaredFields = nextClass.getDeclaredFields();
            ...
        }
    }
    [ERROR] FieldAccess.java:[102,87] 
    incompatible types in assignment.
    found   : @Det Field @OrderNonDet []
    required: @Det Field @Det []
        \end{verbatim}
        \caption{Annotated source code from reflectasm. \vspace{0.5cm}}
        \label{code-reflectasm}
    \end{subfigure}

    \begin{subfigure}[b]{0.95\textwidth}
        \begin{verbatim}
    protected SimpleDataEvent createNextEvent() {
        for (@Det Entry<@Det String, @Det FieldType> entry : fields.entrySet()) {
            ...
        }
        ...
    }
    [ERROR] DataDictionaryEventSource.java:[73,78] 
    incompatible types in enhanced for loop.
    found   : @NonDet Entry<@Det String, @Det FieldType>
    required: @Det Entry<@Det String, @Det FieldType>
        \end{verbatim}
        \caption{Annotated source code from ActionGenerator.}
        \label{code-actiongenerator}
    \end{subfigure}    
    \caption{Errors detected by \TheDeterminismChecker.}
    \label{fig:nondex-source}
\end{figure}
As can be seen from these figures, annotating local arrays and collections
has been sufficient to discover the sources of nondeterminism in most of the projects.
The rest of the projects required annotating the return types of methods.

For the benchmark \<commons-lang>, \cite{nondex} report multiple failing tests (14 flaky tests) due to calls
to \<Class.getDeclaredFields>. Upon inspecting the source code, we find that all of invocations to
\<Class.getDeclaredFields> are made from 5 locations. This means that annotating 5 lines of source code
would have been sufficient to identify the nondeterminism. Having said that, we admit that there could be
significant programmer effort involved in annotating the whole program. On the other hand,~\cite{nondex}
state "we found that manually inspecting these failures was
rather challenging, and we leave it as future work to automate
debugging test failures due to ADINS code". \TheDeterminismChecker reports source locations
which makes it easier for the programmer to fix issues and is orthogonal to the approach taken by NonDex which
reports failing tests.

\TheDeterminismChecker is also capable of detecting nondetermism in test cases. We provide a stub file
for \<junit> in which we annotated the parameters of all the \<assert> methods as \<Det>.
This will cause \TheDeterminismChecker to report any \<junit> test that passes nondeterministic arguments to 
\<assert>s. The test case doesn't even have to be executed for out our tool to detect errors.
It took one of our authors under an hour to create the stub file for junit. This gives us
empirical evidence of the ease of extensibility of our tool.

\todo{Link to det checker repo?}
\todo{If there is time, we could do a second case study, on a program that
  NonDex did not find nondeterminism in.  Our hope would be to find
  nondeterminism that NonDex did not.  Choose a small project that is
  maintained (it has recent commits), so we can communicate with the authors.}

\section{deflaker case study}
\begin{table}[]
    \begin{tabular}{|l|p{5cm}|}
        \hline
        Benchmark, issue & found by det checker? \\ \hline
        achilles, [2] issue \#309 &  Race condition\\ \hline
        achilles, [3] issue \#310 & Same fix for \#309 and \#310 \\ \hline
        checkstyle [4] issue \#4664&test (added to test cases in det checker) \\ \hline
        jackrabbit-oak [6] \#6512&  Unresolved on issue tracker (Race condition issue) \\ \hline
        jackrabbit-oak [7] issue \#6524&  Dead link, didn't find 6524 in issue tracker \\ \hline
        nutz [10] issue \#1283 &  Removed tests (Printing (HTTP's) Response.getstatus()) has Chinese characters,
        compilation with det checker stuck!\\ \hline
        togglz [19] issue \#223 & build issue \\ \hline
        togglz [20] issue \#240 &  build issue\\ \hline
    \end{tabular}
\end{table}
