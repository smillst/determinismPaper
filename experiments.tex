\section{Comparison to previous work}

The state of the art in flaky test detection is NonDex~\cite{nondex}.
\Cref{sec:related} explains how NonDex works.



\begin{itemize}
    \item goals of evaluation: Compare with NonDex and Deflaker
    \item Quantitative comparison: \TheDeterminismChecker finds all bugs reported by NonDex and Deflaker?
    \item Qualitative study of the issues discovered.
    \item System info: 2.3 GHz Intel Core i5, 8 GB 2133 MHz
\end{itemize}


\subsection{Case study with NonDex}\label{sec:nondex-randoop}

We ran NonDex on the same commit of Randoop as we used for the case study
of \cref{sec:randoop-case-study}.  This version contains 3 nondeterminism bugs that
\theDeterminismChecker found.

We modified Randoop by deleting tests that were skipped by its buildfile,
because the NonDex gradle plugin does not respect those settings.

After that, NonDex ran without problems on Randoop.
It completed successfully without reporting any flaky tests.


\todo{check if the bugs discovered by \theDeterminismChecker have test coverage}
\todo{We investigated the tests covering code that \theDeterminismChecker reported as nondeterministic.
If code is covered by tests, NonDex couldn't discover it. Else, its a limitation of NonDex.}
This indicates that the additional programmer effort required by \TheDeterminismChecker is justified
as our tool discovers non-trivial issues and doesn't depend on code coverage or other runtime heuristics.

\subsection{\TheDeterminismChecker on NonDex benchmarks}\label{sec:nondex-benchmarks}

\Cref{sec:nondex-randoop} shows that \theDeterminismChecker finds errors that NonDex does not.
This section determines whether NonDex finds errors that \theDeterminismChecker does not.
Its authors ran NonDex on 195 open-source projects, and NonDex found flaky tests in
21 of them.


The authors also reported the sources of flakiness
after manually inspecting these tests. We ran \TheDeterminismChecker on all these benchmarks with the objective
of measuring recall of our tool. We cloned all 21 repos and switched to the commit that had a flakiness issue as reported 
in~\cite{nondex}. Of these projects, \<handlebars> and \<oryx> have compile time failures which prevents us from running \TheDeterminismChecker on them. For benchmarks \<visualee>, \<easy-batch>, and \<vraptor>, we couldn't find
the sources of flakiness as reported in~\cite{nondex} anywhere in the respective repositories.
\TheDeterminismChecker reported the nondeterministic source locations correctly in the rest of the projects.
All these benchmarks and instructions to reproduce our results can be found at \href{https://github.com/t-rasmud/determinismCaseStudies}{https://github.com/t-rasmud/determinismCaseStudies}.

All the flakiness that NonDex found was due to 7 methods in 3 classes:
\<Class.getDeclaredFields>, \<Class.getDeclaredMethods>, \<Class.getFields>, \<DateFormatSymbols.getZoneStrings>,
\<HashMap.entrySet>, \<HashMap.keySet>, and \<HashMap.values>.  
We provide samples of the annotated source code form these benchmarks and the errors as reported by \TheDeterminismChecker 
in Figures~\ref{code-reflectasm} and~\ref{code-actiongenerator}.
\begin{figure}
    \begin{verbatim}
    static public FieldAccess get (Class type) {
        @Det ArrayList<@Det Field> fields = new ArrayList<Field>();
        ...
        while (nextClass != Object.class) {
            @Det Field @Det[] declaredFields = nextClass.getDeclaredFields();
            ...
        }
    }
    [ERROR] FieldAccess.java:[102,87] [assignment.type.incompatible] 
    incompatible types in assignment.
    found   : @Det Field @OrderNonDet []
    required: @Det Field @Det []
    \end{verbatim}
    \caption{Annotated source code from reflectasm.}
    \label{code-reflectasm}
\end{figure}
\begin{figure}
    \begin{verbatim}
    protected SimpleDataEvent createNextEvent() {
      for (@Det Entry<@Det String, @Det FieldType> entry : fields.entrySet()) {
          ...
      }
      ...
    }
    [ERROR] DataDictionaryEventSource.java:[73,78] [enhancedfor.type.incompatible] 
    incompatible types in enhanced for loop.
    found   : @NonDet Entry<@Det String, @Det FieldType>
    required: @Det Entry<@Det String, @Det FieldType>
    \end{verbatim}
    \caption{Annotated source code from ActionGenerator.}
    \label{code-actiongenerator}
\end{figure}
As can be seen from these figures, annotating local arrays and collections
has been sufficient to discover the sources of nondeterminism in most of the projects.
The rest of the projects required annotating the return types of methods.

For the benchmark \<commons-lang>, \cite{nondex} report multiple failing tests (14 flaky tests) due to calls
to \<Class.getDeclaredFields>. Upon inspecting the source code, we find that all of invocations to
\<Class.getDeclaredFields> are made from 5 locations. This means that annotating 5 lines of source code
would have been sufficient to identify the nondeterminism. Having said that, we admit that there could be
significant programmer effort involved in annotating the whole program. On the other hand,~\cite{nondex}
state "we found that manually inspecting these failures was
rather challenging, and we leave it as future work to automate
debugging test failures due to ADINS code". \TheDeterminismChecker reports source locations
which makes it easier for the programmer to fix issues and is orthogonal to the approach taken by NonDex which
report failing tests.

\TheDeterminismChecker is also capable of detecting nondetermism in test cases. We provide a stub file
for \<junit> in which we annotated all the \<assert> methods as accepting only \<Det> parameters.
This will report any \<junit> test that passes nondeterministic arguments to \<assert>s and the test doesn't
even have to be executed in our case.
\todo{It took one of our authors about an hour to create this stub file - proof of easy extensibility of tool?} 
\todo{Link to det checker repo?}

\begin{table}[]
    \begin{tabular}{|p{1.5cm}|p{1cm}|p{5cm}|p{5cm}|}
        \hline
        Benchmark & Recall? & Error message source & Error msg  \\ \hline
        P1 & Yes & FieldAccess.java: [102,87] & assignment type incompatible \\
        P2 & Yes & YamlWriter.java: [224,28] & cast unsafe  \\
        P3 & Yes & DateTimeZone.java: [731,27] &  return type incompatible \\ 
        P4 & * & compile dependency failure  &   \\ 
        P5 & ** & Class.getDeclaredMethods not found &    \\ 
        P6 & Yes & OptionGroup.java: [55,40]  & argument type incompatible \\ 
        P6 & Yes & Option.java: [157,28]  &  assignment type incompatible\\
        P7(test error & Yes & MultilineRecursiveToString..: [95,35] argument type incompatible & MultilineRecursiveToString...: [208,50]  return type incompatible \\ 
        P7(2) & Yes & FieldUtils.java: [219,84] & assignment type incompatible \\
        P7(2) & Yes & Reflection ToStringBuilder.java: [543,65]  & assignment type incompatible  \\
        P7(2) & Yes & HashCodeBuilder.java: [193,69]  & assignment type incompatible   \\
        P7(2) & Yes & CompareToBuilder.java: [322,65] & assignment type incompatible   \\
        P7(2) & Yes & EqualsBuilder.java: [419,69]  & assignment type incompatible  \\
        P7 & Yes & FieldUtils.java: [200,69] & assignment type incompatible \\
        P7 & Yes & FieldUtils.java: [219,84] & assignment type incompatible  \\
        P7 & Yes & FieldUtils.java: [240,86] & assignment type incompatible  \\
        P8 & ** & getDeclaredFields not found &   \\
        P9 & Yes & Printers.java: [269,97]  &  enhancedfor type incompatible \\
        P10 & ** & getDeclaredFields not found  &  \\
        P11 & Yes & MapUtils.java: [20,50]   & enhancedfor type incompatible  \\
        P12 & Yes  & GSLayerEncoder21.java: [113,91]  & enhancedfor type incompatible \\
        P13 & ** & unbuildable handlebars &  \\
        P14 & Yes  & Maps.java: [91,69] & invalid element type   \\
        P15 & Yes & PkiMessageDecoder.java: [144,29]  &  enhancedfor type incompatible  \\
        P16 & Yes & MethodSorter.java: [56,61]  & assignment type incompatible  \\
        P17 & Yes & JSONObject.java: [674,51]  & assignment type incompatible  \\
        P18 & Yes & SubstitutableLoggerTest.java: [67,61]   & enhancedfor type incompatible  \\
        P19 & Yes & DataDictionaryEventSource.java: [73,78]  &  enhancedfor type incompatible  \\
        P20 & Yes & SaverImpl.java: [43,69]  &  return type incompatible  \\
        P21 & Yes & RestDocumentation.java: [419,50] &  argument type incompatible   \\ \hline
    \end{tabular}
\end{table}

\todo{If there is time, we could do a second case study, on a program that
  NonDex did not find nondeterminism in.  Our hope would be to find
  nondeterminism that NonDex did not.  Choose a small project that is
  maintained (it has recent commits), so we can communicate with the authors.}

\section{deflaker case study}
\begin{table}[]
    \begin{tabular}{|l|p{5cm}|}
        \hline
        Benchmark, issue & found by det checker? \\ \hline
        achilles, [2] issue \#309 &  Race condition\\ \hline
        achilles, [3] issue \#310 & Same fix for \#309 and \#310 \\ \hline
        checkstyle [4] issue \#4664&test (added to test cases in det checker) \\ \hline
        jackrabbit-oak [6] \#6512&  Unresolved on issue tracker (Race condition issue) \\ \hline
        jackrabbit-oak [7] issue \#6524&  Dead link, didn't find 6524 in issue tracker \\ \hline
        nutz [10] issue \#1283 &  Removed tests (Printing (HTTP's) Response.getstatus()) has Chinese characters,
        compilation with det checker stuck!\\ \hline
        togglz [19] issue \#223 & build issue \\ \hline
        togglz [20] issue \#240 &  build issue\\ \hline
    \end{tabular}
\end{table}
