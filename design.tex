\section{Design}
\subsection{Type checking background}
The major components of a type system include: 1) \textit{types}, 2) \textit{subtyping rules}, and 3) \textit{dataflow analysis}.
A \textit{type} serves as an abstraction for the set of acceptable values for any expression. The types in a type system form a lattice of finite height. 
The hierarchy of types in this lattice defines subtyping relationships among them.
In our framework, we require every type hierarchy to define a unique\<@Top> and a \<@Bottom> element. This ensures that
any given pair of types has a \textit{least upper bound} and a \textit{greatest lower bound}.
Throughout this paper, we use the notation \<@A> <: \<@B> to denote that type \<@A> is a subtype of type \<@B>.
As an illustration of the type hierarchy, consider the lattice of types shown in Figure~\ref{fig-example-lattice}.
\begin{figure}
	\begin{center}
		\includegraphics[scale=0.15]{lattice}
	\end{center}
	\caption{Example type hierarchy}
	\label{fig-example-lattice}
\end{figure}
In this type system, \<@C> is a subtype of \<@A> as well as \<@B> and types \<@A> and \<@B> are incomparable.
The type checker now performs additional type checking (similar to javac's type checking) with respect to this type hierarchy
and reports any violations. The snippet in Figure~\ref{code-invalid1} would result in an error at the assignment statements:
\begin{figure}
	\begin{verbatim}
	@A int x; @B int y; @C int z;
	x = y;    // Because types @A and @B are incomparable.
	z = x;    // Because @C is a subtype of @A.
	\end{verbatim}
\caption{Example: Invalid assingment}
\label{code-invalid1}
\end{figure}

Similarly, if the return type of a method is annotated as \<@C> but it returns a type that has either \<@A> or \<@B>, the
checker would report an error at compile time.

%Method overriding and example
For method overriding, the usual rules apply for parameters and arguments i.e covariant subtyping for parameters
and contravariant subtyping for return types. Consider the example in Figure~\ref{code-invalid2} where method \<foo> of \<class X> is overridden
in \<class Y>.
\begin{figure}
	\begin{verbatim}
	class X {
	    @B int foo (@C int param) {}
	}
	class Y extends X {
	    @C int foo (@B int param) {}
	}
	\end{verbatim}
	\caption{Example: Invalid Method override}
	\label{code-invalid2}
\end{figure}

The overriding method is invalid for two reasons: type of the parameter (\<@B>) is not a subtype of the parameter type in the overriden method (\<@C>) and the return type (\<@C>) is not a supertype of the return type of the overriden method (\<@B>).

%collections type parameters - invariant
Collection types are invariant. So, if a \<List> x is declared as \<@A List><\<@A String>> \<x;> and another \<List y> is declared
as  \<@A List><\<@B String>> \<y;>, writing \<x = y> would result in an error.

%covariant array types
Arrays follow covariant subtyping rules in java. Therefore, the assignment statement \<@A int @A[] x = y;> where \<y> was 
declared as \<@B int @A[] y> would type check without any warning.

\subsection{Determinism type hierarchy}
The Determinism type system uses the following type qualifiers (see Figure~\ref{fig-determinism-hierarchy}) (We have omitted the
\<@Top> and \<@Bottom> types for brevity):
\begin{itemize}
	\item \<@NonDet> indicates
	that the expression might have different values in two different executions.
	\item \<@OrderNonDet> indicates that
	a collection (i.e any class that is a subtype of java.util.Collection, java.util.Iterator, or java.util.Map) or an array will have the same elements in every execution, but in a
	possibly different order.  \<@OrderNonDet> may only be written on
	collections and arrays.
	\item \<@Det> indicates that
	the expression evaluates to the same value (with respect to \<.equals()>) in all
	executions; for a collection, iteration also yields the values in the same
	order.
\end{itemize}

\begin{figure}
	\begin{center}
		\includegraphics[scale=0.5]{determinism}
	\end{center}
	\caption{Determinism type hierarchy}
	\label{fig-determinism-hierarchy}
\end{figure}

In Figure~\ref{code-determinism}, we present some of the JDK methods that we have annotated with our determinism types and give examples of
client code that would produce errors at compile time.
\begin{figure}
	\begin{verbatim}
	// Annotated JDK methods
	public class Random implements java.io.Serializable {
	    public @NonDet Random() {}
	}
	public class PrintStream extends FilterOutputStream 
	    implements Appendable, Closeable {
	    public void println(@Det Object x) {}
	}
	
	// Client code
	class Client {
	    void test() {
	        @NonDet Random rnd = new Random(); // No error.
	        System.out.println(rnd);                    // Error - println takes @Det arguments.
	        @Det Random rnd1 = new Random();  // Error - subtyping rules violated.
	    }
	}
	\end{verbatim}
	\caption{Example: Errors detected by determinism checker}
	\label{code-determinism}
\end{figure}

\subsection{Additional typing rules for collection elements}
Lists, set and maps - element types have to be subtypes of collection type 
Explain iterator and extracting elements of an ordernondet collection here
Examples of valid and invalid types

\subsection{Avoid aliasing unsoundness}
Give an example of unsoundness 
Recall CLIMB-to-top rule and defaulting choice for local collections (to avoid too many warnings)
Required user annotations for collections and arrays

\subsection{Special cases of polymorphism}
Explain polymorphism first
Explain modifiers to Polymorphic annotations
Poly up and down for ordernondetermistic types
Poly use for avoiding polluting det/ordernondet collections
Subtype hierarchy among all variants of Poly
Possibility of type refinement?	

\subsection{Discussion on defaulting rules}
Det - default, but @Poly is the default for parameters and return types
Choice of defaults on class type, constructors and method params and return types

\subsection{Additional hardcoded rules for precision}
Example: equals on HashSet
Discussion on System properties - env, line, file and path separator.

\subsection{Annotating more classes/providing more specifications}
Ease of annotating more JDk classes
User provided stub files to override existing behavior
