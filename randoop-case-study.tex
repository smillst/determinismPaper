\section{Case study}\label{sec:randoop-case-study}

To evaluate the usability of \theDeterminismChecker,
we applied it to the Randoop test
generation tool~\ifanonymous\citepalias{randoop-tool}\else\cite{PachecoLEB2007}\fi.
We also wrote specifications for libraries it uses, such as the JDK, JUnit,
and others.
Like \theDeterminismCheckerImplementation,
all the case study materials are publicly available at \myurl{\todo{url for
    case study}} for reproducibility.


\subsection{Subject program}\label{sec:subject-program}

We chose Randoop because 
it is frequently used in software engineering experiments,
it is actively maintained,
and its developers have struggled with nondeterminism~\cite{randoop-issue-tracker,randoop-mailing-lists}.

Randoop is intended to be deterministic, when invoked on a deterministic
program~\cite{randoop-manual}.\footnote{Users of Randoop can pass in a different seed in order to
  obtain a different deterministic output.  Randoop has command-line
  options that enable concurrency and timeouts, both of which can lead to
  nondeterministic behavior.}
However, Randoop was not deterministic.  This caused the developers
problems in 
reproducing bugs reported by users, 
reproducing test failures during development, and
understanding the effect of changes to Randoop by comparing executions of two
similar variants of Randoop.

The developers took extensive action to detect and mitigate the effect of nondeterminism.
They used Docker images to run tests, to avoid system dependencies such as
a different JDK having a different number of classes or methods.
They wrote tests with relaxed oracles (assertions) that permit multiple
possible answers --- for example, in code coverage of generated tests.
They used linters such as Error Prone, which warns if \<toString> is used on
array objects, which don't override \<Object.toString> and therefore print a
hash code which may vary from run to run.
They used a library that makes hash codes deterministic, by giving each
object of a type a unique ID that counts up from 1 rather than using a
memory address as \<Object.hashCode> does.
They wrote specialized tools to preprocess output and logs to make them easier
to compare, such as by removing or canonicalizing hash codes, dates, and
other nondeterministing output (commits e15f9155--b473fd14).
Each of these efforts was helpful, but they were not enough to solve the problem.

In July 2017, the Randoop developers spent two weeks of full-time work to
eliminate unintentional nondeterministic behavior in Randoop.
Their methodology was to repeatedly
 run Randoop with verbose logging enabled,
 look for differences in logging output,
 find the root cause of nondeterminism,
 and eliminate it.
Some of the nondeterminism was in libraries, such as the JDK\@.
The most common causes were \<toString> routines and iteration order of sets and maps.
The most common fixes were to change the implementation of \<toString>
and to use \<LinkedHashSet> and \<LinkedHashMap> or to sort collections
before iterating over them.
The developers did not make every \<Set> and \<Map> a \<LinkedHashSet> or \<LinkedHashMap>, because that
would have increased memory and CPU costs.  They chose not to make every
order-nondeterministic \<List> a \<Set>, for similar reasons:  deduplication was
not always needed and would have increased costs.

That coding sprint did not find all the problems.
The developers debugged and fixed 5 additional determinism defects over the
next 12 months, using a similar methodology
(commits c15ccbf2, 44bdeebd, 5ff5b4c4, 22eda87f, and b473fd14).


% [2413 changed lines in the diffs.
% (This number slightly overstates the number of code changes made, because sometimes changing code would result in code formatting changes, and some changes in those commits are unrelated to determinism, such as documentation improvements.)]
We analyzed a version of Randoop from late February 2019 (commit 0a8e63fb), over 6 months after the most recent determinism bug fix.


\subsection{Methodology}

In brief, we wrote type qualifiers in the Randoop source code to express its
determinism specification
We then ran
\theDeterminismChecker.  Each warning indicated a mismatch between the
specification and the implementation, which we addressed by changing our
specification or reporting a bug in the implementation.

We annotated the core of Randoop (the \<src/main/java> directory), which
contains 24K non-comment, non-blank lines of code.
% (41 KLOC including blanks and comments).
% [Maybe we will add 1600 LOC of agent code.]
We did not annotate Randoop's test suite.

We annotated one package at a time, starting with the most central packges
that are most depended upon.  Within a package, we followed a similar
strategy, annotating supertypes first.  If the determinism of classes and methods had been
documented, then our annotation effort
would have been easy, just converting English into type qualifiers.
Unfortunately, this was not the case: we had to reverse-engineer each
specification, largely from the methods it calls.  If a method $m$ calls a
method that we had previously annotated as nondeterministic, we annotated
$m$ as nondeterministic.
Sometimes after we
annotated a subclass, we had to go back and change existing annotation on
the supertype or elsewhere because the subclass implementation was
inconsistent with the specification we had guessed for the supertype.
After resolving most type-checking warnings by adding or changing
annotations, we manually examined each remaining one to determine whether
it was a bug or a false positive warning.

% run: ./gradlew clean compileJava;./gradlew clean compileJava;./gradlew clean compileJava;./gradlew clean compileJava;./gradlew clean compileJava
% then read the times reported by Gradle.
% javac 5 trials:   31, 19, 18, 18, 18.
% \theDeterminismChecker 5 trials: 45s 39s 32s 31s 31s
\<javac> takes 18 seconds to compile all files of Randoop.
While also running \theDeterminismChecker as a compiler plugin, \<javac> takes 32 seconds to verify determinism and compile all files of Randoop.
% godwit.  Info comes from `cat /proc/cpuinfo` and from `top`.
These numbers are the median of 5 trials on an 8-core Intel i7-3770 CPU running at 3.40GHz with 
32GB of memory.


\subsection{Results}

\TheDeterminismChecker found \numRandoopBugs previously-unknown nondeterminism bugs in Randoop.
The Randoop developers accepted our bug reports and committed fixes to the repository. A summary
of these bugs follows, according to the Randoop developers' categorization:

\begin{description}
\item[Severe issues]
  \strut
\begin{description}
\item[\bugHashSet]
One use of \<HashSet> could cause a problem if a type variable's lower or upper
bound has a type parameter that the type variable itself does not have.
This situation does occur, even in Randoop's test suite.
The developers fixed this by changing a \<HashSet> to \<LinkedHashSet>
(commit c975a9f7, shown in \cref{fig:randoop-bug-hashset}).
\TheDeterminismChecker confirmed that 
25 other uses of \<new HashSet> were acceptable, as were 15 uses of \<new HashMap>.

\item[\bugClasspath]
Randoop used the CLASSPATH environment variable in preference to the
classpath passed on the command line.
This could have led to incorrect behavior, both in Randoop's test suite and in the field,
if a user set the environment variable.
The developers fixed it by changing Randoop to not read the environment variable
(commit 330e3c56, shown in \cref{fig:randoop-bug-getenv}).
\TheDeterminismChecker verified that all other uses of system and Java
properties did not lead to nondeterministic behavior.
\end{description}

\item[Minor issues]
\strut
\begin{description}
 
\item \bugHashcodeOutput:
  Diagnostic output printed a hash code for brevity.
  The developers changed it to have deterministic output (commit 661a4970).
  Although the Randoop developers classified this issue as minor, it is
  very similar to ones they fixed during their two-week coding sprint.

\item \bugTimestampOutput:
  Diagnostic output printed a timestamp.
  The developers fixed it by making it obey an
  option about whether to print timestamps (commit a460df97).
  The developers may not have noticed this because their log-postprocessing
  tools removed them from the log when doing comparisons.

\end{description}

\end{description}

\begin{figure}

\noindent
In \<Minimize.java>:

\begin{Verbatim}
151:-  private static final String SYSTEM_CLASS_PATH = System.getProperty("java.class.path");

913:-    String command = "javac -classpath " + SYSTEM_CLASS_PATH + PATH_SEPARATOR + ".";
913:+    String command = "javac -classpath .";
914:     if (classpath != null) {
915:       // Add specified classpath to command.
916:       command += PATH_SEPARATOR + classpath;
917:     }

948:-    String classpath = SYSTEM_CLASS_PATH + PATH_SEPARATOR + dirPath;
948:+    String classpath = dirPath;
949:     if (userClassPath != null) {
950:       classpath += PATH_SEPARATOR + userClassPath;
951:     }
\end{Verbatim}

\noindent
In \<MinimizerTests.java>:

\begin{Verbatim}
55:-    String classPath = "";
55:+    String classPath = JUNIT_JAR;
56:     if (dependencies != null) {
57:       for (String s : dependencies) {
58:         Path file = Paths.get(s);
59:         classPath += (pathSeparator + file.toAbsolutePath().toString());
60:       }
61:     }
\end{Verbatim}
\caption{Fixes made by the Randoop developers in response to our bug report
  about use of environment variables.  Lines starting with ``\<->'' were
  removed and those starting with ``\<+>'' were added.
  \TheDeterminismChecker verified all other uses of system and Java properties.}
\label{fig:randoop-bug-getenv}
\end{figure}


We reported another suspicious case of order-nondeterminism, in the
\<SpecificationCollection>\-\<.findOverridden> method.  The Randoop developers explained it was
acceptable, after tracing the flow through the program.  (One said, ``This
looks OK to me \ldots\ it took me a little while to decide that.'')  The fact
depended on subtle, undocumented invariants about Randoop that we had not
been able to reverse-engineer on our own.




\subsection{False positive warnings}

\todo{Java 8 lambdas could help.}


\subsection{Annotation effort}

\todo{Report the number of annotations required, and say a few words about
  the process and the effort required.}

\todo{Easier for someone familiar with the codebase.  Easier on new code.}

It's higher than we would prefer.

The large number of \<@Det> annotations has two main reasons.

One is that we annotated some core components of Randoop to require all
boolean expressions used in conditionals to be deterministic.  (This is an
option in \theDeterminismCheckerImplementation, which increases soundness;
see \cref{sec:threats}.)  This forced
their clients --- transitively, much of the Randoop codebase --- to be
annotated as deterministic.
These annotations are not incorrect, but they are stricter than necessary
because some method types could otherwise be qualifier-polymorphic.
This would make them usable in more contexts.  It would also reduce the
number of necessary annotations, since qualifier-polymorphism (the
\<@PolyDet> annotation) is the default for
formal parameter and return types.  We plan to re-do the annotation effort
from scratch, and the number of annotations will be much lower.

The second reason is a limitation in \theDeterminismCheckerImplementation,
which is inherited from the Checker Framework~\cite{checker-framework-tool} upon which
\theDeterminismChecker is built.
The Checker Framework does not support qualifier polymorphism over
classes.  This means that fields must be annotated as deterministic.  Our annotations in
Randoop use qualifier polymorphism extensively on methods but cannot use it
on classes, and this leads to many more \<@Det> annotations than would be
needed otherwise.


Even though the number of annotations is higher for our prototype
implementation than we would prefer, it still compares favorably to the
extensive effort by the Randoop developers (\cref{sec:subject-program}),
especially given that that \theDeterminismChecker found issues that the
developers had not.
