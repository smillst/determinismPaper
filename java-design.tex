\section{Determinism types for Java}\label{sec:java-types}

We have implemented our type system for Java, in a tool named \theDeterminismChecker.
The implementation consists of 1200 lines of Java
code, plus 1800 lines of tests (all line measurements are non-comment,
non-blank lines), a manual, examples, etc.
\TheDeterminismChecker requires Java version 8.
It is publicly available at
\myurl{URL for \theDeterminismChecker}.


\subsection{Determinism type qualifiers}

A type qualifier is written in Java source code as a type annotation.
A type annotation has a leading ``\<@>'' and is written immediately before a
Java basetype, as in \<@Positive int> or \codeid{@NonEmpty List<@NonNull String>}.

\TheDeterminismChecker supports the type qualifiers \<@NonDet>,
\<@OrderNonDet>, and \<@Det> (and others described below).
The meaning of \<@Det> is with respect to value
equality, not reference equality; that is,
values on different executions are the same with respect to \<.equals()>,
not \<==>.

Our implementation treats arrays analogously to collections:
the semantics and rules are similar even though the syntax varies.
For simplicity this
paper uses the term ``collection'' and the type \<Collection> to represent
collections and arrays.
Collections include any type (including user-defined classes) that
implements the \<Iterable> or \<Iterator> interfaces; this includes all
Java collections such as \<List>s and \<Set>s.
Our implementation also supports any type that implements the \<Map>
interface.


\Cref{code-determinism} presents some of the JDK methods that we have annotated with our determinism types and give examples of
client code that would produce errors at compile time.
%\begin{figure}
%    \begin{verbatim}
%    // Annotated JDK methods
%    public class Random implements java.io.Serializable {
%        public @NonDet Random() {}
%    }
%    public class PrintStream extends FilterOutputStream 
%        implements Appendable, Closeable {
%        public void println(@Det Object x) {}
%    }
%    
%    // Client code
%    class Client {
%        void test() {
%            @Det double d = Math.random(); // Error - subtyping rules violated.
%            @NonDet double nd = Math.random(); // No error.
%            System.out.println(nd); // Error - println takes @Det arguments.
%        }
%    }
%    \end{verbatim}
%    \caption{Example: Errors detected by \theDeterminismChecker.}
%\todo{Use real examples of bugs from case studies, throughout.  Artificial
%  examples are less compelling (and lead the reader to wonder whether no
%  real example exist).  Put the first example of an error in a figure in
%  Section 1, to help with motivating the problem.}
%    \label{code-determinism}
%\end{figure}

\begin{figure}
    \begin{verbatim}
    // Annotated JDK methods
    public interface Map<K,V> {
        @PolyDet Set<Map.Entry<K, V>> entrySet(@PolyDet Map<K,V> this);
    }
    public interface Iterator<E> {
        @PolyDet("up") E next(@PolyDet Iterator<E> this);
    }
    
    // Client code
    public class MapUtils {
        public static <K extends @PolyDet Object, V extends @PolyDet Object> 
                                @Det String toString(@PolyDet Map<K,V> map) {
            ...
            for(Map. @Det Entry<K,V> entry : map.entrySet()) { ... }
        }
    }
    [ERROR] MapUtils.java:[20,50] [enhancedfor.type.incompatible] 
    incompatible types in enhanced for loop.
    found : @PolyDet Entry<K extends @PolyDet Object,V extends @PolyDet Object>
    required: @Det Entry<K extends @PolyDet Object,V extends @PolyDet Object>
    \end{verbatim}
    \caption{Example: Error detected by \theDeterminismChecker in \<scribe-java>~\cite{nondex}.}
%    \todo{Use real examples of bugs from case studies, throughout.  Artificial
%        examples are less compelling (and lead the reader to wonder whether no
%        real example exist).  Put the first example of an error in a figure in
%        Section 1, to help with motivating the problem.}
    \label{code-determinism}
\end{figure}

\begin{itemize}
\item
In \theDeterminismCheckerImplementation,
type polymorphism is handled by Java's generics mechanism, which
\theDeterminismChecker fully supports, including class and method generics,
inference, etc.
Given the Java declaration
\begin{Verbatim}
<T> T identity(T arg) { return arg; }
\end{Verbatim}
the type of \<identity(arg)> is the same as the type of
\<arg>, and a programmer can write a type such as \codeid{List<@NonDet
  Integer>} (but see below for details about collections).
\item
Basetype polymorphism is enabled by writing a type qualifier on a use of a
type variable, which overrides the type qualifier at the instantiation
site.
For example, a \<choose> operation on sets could be defined in Java as
\begin{Verbatim}
class ChooseableSet<T> implements Set<T> {
  // return an arbitrary element from the set
  @NonDet T choose();
}
\end{Verbatim}
\item
\todo{We do not support qualifier polymorphism on classes, only on methods.}
Java does not provide a syntax that can be used for qualifier polymorphism,
so we use a special type qualifier name, \<@PolyDet>.
A qualifier-polymorphic method \<m> with signature $\forallt{\kappa} \kappa\ \<int> \times \<Det boolean> \rightarrow
\kappa\ \<String>$ would be written in our dialect of Java as
\begin{Verbatim}
@PolyDet String m(@PolyDet int, @Det boolean)
\end{Verbatim}
Each use of \<@PolyDet> stands for a use of the qualifier variable
$\kappa$, and there is no need to declare the qualifier variable $\kappa$.
\TheDeterminismChecker currently supports
qualifier
polymorphism on methods but not on classes.
Therefore, \<@PolyDet> may be written in methods (signatures and bodies)
but not on fields.
\end{itemize}

\subsection{Java collection types}\label{sec:maps-java}

A \<Map> is deterministic if its \<entrySet> is deterministic.
In other words, iterating over this \<entrySet> is guaranteed to produce the same values in the exact same order across executions.
The \<Map> interface in Java doesn't define an \<iterator()> interface. Therefore it's sound to equate the determinism of the \<Set>
returned by \<entrySet()> to the determinism of the \<Map>. Interestingly, we found that every implementation of the \<Map> 
interface had the following property: if the \<Set> returned by \<entrySet()> has a determinism type $\kappa$, then
the \<Set>s returned by \<keySet()> and \<values()> also have the exact same determinism type $\kappa$.

The most widely used \<Map> implementations have the following properties:
\begin{itemize}
    \item \<HashMap> is implemented in terms of a hash table, which never
      guarantees deterministic iteration over its entries. A \codeid{@Det
        HashMap} does not exist.
    \item \<LinkedHashMap>, like \<List>, can have any of the \<@NonDet>,
      \<@OrderNonDet>, or \<@Det> type qualifiers. Iterating over a
      \<LinkedHashMap> returns
    its entries in the order of their insertion. An \<OrderNonDet
    LinkedHashMap> can be created by calling its constructor with a
    \<@OrderNonDet HashMap>.
    \item \<TreeMap> can either be \<@Det> or \<@NonDet>. An \<@OrderNonDet
      TreeMap> doesn't exist because the entries are always ordered.
\end{itemize}

\TheDeterminismChecker prohibits the creation of a \codeid{@Det HashMap} or an \codeid{@OrderNonDet TreeMap}.
\Cref{fig-creation-rules} formalizes the type well-formedness rules for
Java \<Map>s and \<Set>s.

\begin{figure}
    $\infer[\rulename{valid hashmap}]{\vdash: \|\kappa\ \<HashMap>|}{\kappa \in \{ \<OrderNonDet>, \<NonDet> \}}$
    
    \bigskip
    
    $\infer[\rulename{valid treemap}]{\vdash: \|\kappa\ \<TreeMap>|}{\kappa \in \{ \<Det>, \<NonDet> \}}$
    
    \bigskip
    
    $\infer[\rulename{valid hashset}]{\vdash: \|\kappa\ \<HashSet>|}{\kappa \in \{ \<OrderNonDet>, \<NonDet> \}}$
    
    \bigskip
    
    $\infer[\rulename{valid treeset}]{\vdash: \|\kappa\ \<TreeSet>|}{\kappa \in \{ \<Det>, \<NonDet> \}}$
    \caption{Type well-formedness rules for subclasses of \<Map> and \<Set>.}
    \label{fig-creation-rules}
\end{figure}

The JDK implements \<LinkedHashSet> as a subclass of \<HashMap>\todo{should
  this be HashSet?  It's not true as written.}
in order to inherit parts of \<HashMap>'s implementation.
\todo{Talk about this design choice. Josh Bloch's book: "If the code surrounding the first declaration depended on LinkedHashSet's ordering policy,
    then it would be incorrect to substitute HashSet for LinkedHashSet in the declaration, because HashSet makes no guarantee concerning iteration order."} 
\todo{The above is not clear.  What are the consequences for our
  implementation.  What goes wrong or is hard to annotate or is surprising?
  I'm not sure what is the point of this paragraph.}


\subsection{Defaulting rules}\label{defaulting}

\TheDeterminismChecker applies a default qualifier at each unannotated type
use (except uses of type variables, which already stand for a type that was
defaulted at the instantiation site).
This does not change the expressivity of the type system; it merely makes
the system more convenient to use by reducing programmer effort and code clutter.

The default annotation for most unannotated types is \<@Det>, because
programmers generally expect their programs to behave the same when re-run
on the same inputs.

Formal parameter and return types default to \<@PolyDet>.  That is, a
programmer-written method

\begin{Verbatim}
  int plus(int a, int b) { ... }
\end{Verbatim}

\noindent
is treated as if the programmer had written

\begin{Verbatim}
  @PolyDet int plus(@PolyDet int a, @PolyDet int b) { ... }
\end{Verbatim}

\noindent
and its function type is

$\forallt{\kappa}  \kappa\ \<int> \times \kappa\ \<int> \rightarrow \kappa\ \<int>$

\noindent
This choice type-checks if the method body does not make calls to any
interfaces that require \<@Det> arguments or produce \<@NonDet> results.





\begin{itemize}
\item
  If a formal parameter/return type is an array, its component type defaults to
  \<@PolyDet>.
\item
  As an exception, the return type of a method with no unannotated or
  \<@PolyDet> formal parameters (including the receiver) defaults to
  \<@Det>.
\end{itemize}

These choices permit all possible arguments to an unannotated method.

In \theDeterminismChecker, we chose \<PolyDet> as the default for all 
method parameters and return types including constructors.
The rationale for this design choice was to not make \theDeterminismChecker too restrictive by making everything \<Det>.

\begin{verbatim}
@PolyDet int foo(@PolyDet int x) { ... }

void bar(@NonDet int random, @Det int value) {
    @NonDet int x = foo(random);      // no error
    @Det int y = foo(value);          // no error
    System.out.println(foo(random));  // error
}
\end{verbatim}
In the example above, the method \codeid{foo} is annotated with the \<PolyDet> type qualifier which allows
the caller method \codeid{bar} to invoke it with both \<Det> and \<NonDet> arguments. \TheDeterminismChecker flags an error 
only when the returned value is used in a way that breaks any deterministic specification (Printing a \<NonDet> value
breaks our determinism guarantees).





\subsection{Polymorphism}\label{java-polymorphism}

\OurTypeSystem supports three types of polymorphism:  type
polymorphism, basetype polymorphism, and qualifier polymorphism.
These apply to both classes and methods.

\begin{itemize}
\item
In \theDeterminismCheckerImplementation,
type polymorphism is handled by Java's generics mechanism, which
\theDeterminismChecker fully supports, including class and method generics,
inference, etc.
Given the Java declaration
\begin{Verbatim}
<T> T identity(T arg) { return arg; }
\end{Verbatim}
the type of \<identity(arg)> is the same as the type of
\<arg>, and a programmer can write a type such as \codeid{List<@NonDet
  Integer>} (but see below for details about collections).
\item
Basetype polymorphism is enabled by writing a type qualifier on a use of a
type variable, which overrides the type qualifier at the instantiation
site.
For example, a \<choose> operation on sets could be defined in Java as
\begin{Verbatim}
class ChooseableSet<T> implements Set<T> {
  // return an arbitrary element from the set
  @NonDet T choose();
}
\end{Verbatim}
\item
Java does not provide a syntax that can be used for qualifier polymorphism,
so we use a special type qualifier name, \<@PolyDet>.
A qualifier-polymorphic method \<m> with signature $\forallt{\kappa} \kappa\ \<int> \times \<Det boolean> \rightarrow
\kappa\ \<String>$ would be written in our dialect of Java as
\begin{Verbatim}
@PolyDet String m(@PolyDet int, @Det boolean)
\end{Verbatim}
Each use of \<@PolyDet> stands for a use of the qualifier variable
$\kappa$, and there is no need to declare the qualifier variable $\kappa$.
\TheDeterminismChecker currently supports
qualifier
polymorphism on methods but not on classes.
Therefore, \<@PolyDet> may be written in methods (signatures and bodies)
but not on fields.
\end{itemize}

\todo{Explain @PolyDet("up"), "down", "use".}



When a user writes a polymorphic qualifier on a method signature or a type parameter,
it indicates that it could be instantiated
%\todo{Should all occurrences of ``resolve'' be ``can be instantiated''} 
to any type in the type system depending on how it is used.
In \theDeterminismChecker, we define a polymorphic qualifier \<PolyDet>.
One of the most common locations for a polymorphic qualifier is at a method signature.
Consider the following declaration of addition:
\begin{verbatim}
@PolyDet int plus(@PolyDet int a, @PolyDet int b) { return a+b; }
\end{verbatim}
\todo{It has the standard meaning.  There are two ways to interpret this.}
There are two valid instantiations for this declaration:
\begin{Verbatim}
  @NonDet int plus(@NonDet int a, @NonDet int b) { return a+b; }
  @Det int plus(@Det int a, @Det int b) { return a+b; }
\end{Verbatim}
This indicates that method \<foo> can be called with arguments having any of the \codeid{@Det} or \codeid{@NonDet} type qualifiers.
%   (\<@OrderNonDet> is not allowed because it is invalid on primitive types).
 \<PolyDet> gets instantiated to the least upper bound of
the actual types on arguments. For instance, if this method is called as \codeid{foo(@Det String arg1, @NonDet boolean arg2)}, \theDeterminismChecker instantiates the method declaration as \codeid{@NonDet int foo(@NonDet String param1, @NonDet boolean param2)}
causing the return type to have the type qualifier \<NonDet>.



\subsection{Dataflow analysis and type refinement}\label{sec:dataflow-java}

\todo{Relate this to defaulting.}

It also performs dataflow analysis and refines the types of these locals, thereby reducing the qualifier burden 
on the programmer. Consider the example below:
\begin{verbatim}
void foo(@Det int x) {
    @NonDet int y = x;    // Type of y gets refined to @Det.
    @Det int z = y;       // No error here.
}
\end{verbatim}
In the example above, even though the local variable \codeid{y} was declared to be \codeid{NonDet}, it gets
type refined to \codeid{Det} after the first assignment statement. As the result, the assignment of \codeid{y}
to a \codeid{Det} variable \codeid{z} is sound. In the following example,
\begin{verbatim}
void foo(@NonDet Object x, @Det Object y) {
    x = y;                // No type refinement for x.
    @Det Object z = x;    // Error.
}
\end{verbatim}
\theDeterminismChecker reports a warning at the second assignment statement of \codeid{foo}. Type refinement only applies to locals. Refining non-locals can result in side effects making the analysis unsound.

With the above rules, \theDeterminismChecker will automatically annotate a local collection with type \<NonDet> and its
type arguments will get the type qualifier \<Det>. For example, a locally declared \codeid{List} of \codeid{Strings} will be automatically annotated
as \codeid{NonDet List<Det String>}. Recall from~\cref{collection-rules} that \theDeterminismChecker does not allow this type on
any collection. While this is still sound, it will result in \theDeterminismChecker reporting a lot of errors because every locally declared 
collection gets annotated with this invalid type. To avoid this situation, we make an exception to the defaulting rules for local collections
and annotate their type parameters also with \<NonDet>. So a local list of Strings gets the default qualifier of \codeid{NonDet List<NonDet String>}. While this defaulting eliminates the possibility of automatically annotating locals collections with an invalid
type, it could result in a high number of false positives. In the following code snippet,
\begin{verbatim}
void test(@Det List<@Det String> argList) {
    List<String> localList = argList;
}    
\end{verbatim}
\theDeterminismChecker would report an error at the assignment statement since the inferred type for \codeid{localList} is 
\codeid{NonDet List<NonDet> String} and since collections types are invariant.
We therefore recommend that programmers explicitly annotate
all local variables that are collections to reduce false positives.

\subsection{Precision improvements}\label{sec:precision-java}

The return type of \<System.getenv>, which reads an operating system
environment variable, is always \<NonDet>.
The return type of \codeid{System.getProperty} is usually \<NonDet>. However,
the result is \<Det> if the argument is \codeid{"line.separator"}; although
it varies by operating system, many programs including \<diff> hide those
differences from the user.
The result is also deterministic for \codeid{"path.separator"} and
\codeid{"file.separator"}, because these lead to the same behavior given
corresponding environments.
The user can specify input properties that must be passed on the \<java>
command line and thus act like inputs to the program; these are also
treated as deterministic.
The inputs to a program are also treated as \<Det>.  That is, the parameter
type of the \<main> method is implicitly annotated as
\<@Det String @Det []>, a deterministic array of deterministic strings.

