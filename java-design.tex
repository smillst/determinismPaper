\section{Determinism types for Java}\label{sec:java-types}

In Java, a type qualifier is written as a type annotation (which has a leading \<@>), as in
\<@Positive int>.

Our implementation
handles array types, and any class (including user-defined classes) that
implements the \<Iterable> or \<Iterator> interfaces; this includes all
Java collections such as \<List>s and \<Set>s.  For simplicity, and because
the semantics and rules are similar even though the syntax varies, this
paper uses the term ``collection'' and the type \<Collection> to represent
all these types.


(In Java,
\<HashMap> cannot be deterministic, but \<TreeMap> and \<LinkedHashMap>
can.\todo{forward reference?})



\Cref{code-determinism} presents some of the JDK methods that we have annotated with our determinism types and give examples of
client code that would produce errors at compile time.
\begin{figure}
    \begin{verbatim}
    // Annotated JDK methods
    public class Random implements java.io.Serializable {
        public @NonDet Random() {}
    }
    public class PrintStream extends FilterOutputStream 
        implements Appendable, Closeable {
        public void println(@Det Object x) {}
    }
    
    // Client code
    class Client {
        void test() {
            @Det double d = Math.random(); // Error - subtyping rules violated.
            @NonDet double nd = Math.random(); // No error.
            System.out.println(nd); // Error - println takes @Det arguments.
        }
    }
    \end{verbatim}
    \caption{Example: Errors detected by \theDeterminismChecker.}
\todo{Use real examples of bugs from case studies, throughout.  Artificial
  examples are less compelling (and lead the reader to wonder whether no
  real example exist).  Put the first example of an error in a figure in
  Section 1, to help with motivating the problem.}
    \label{code-determinism}
\end{figure}
